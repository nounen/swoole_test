## 多进程共享数据
* 由于 PHP 语言不支持多线程，因此 **Swoole 使用多进程模式**。

* 在多进程模式下存在 *进程内存隔离*，**在工作进程内修改 global 全局变量 和 超全局变量时，在其他进程是无效的。**


### 进程隔离
```php
$fds = array();
$server->on('connect', function ($server, $fd){
    echo "connection open: {$fd}\n";
    global $fds;
    $fds[] = $fd;
    var_dump($fds);
});
```

* `$fds` 虽然是全局变量，但只在当前的进程内有效。Swoole 服务器底层会创建多个 Worker 进程，在 `var_dump($fds)` 打印出来的值，只有部分连接的 fd。

* 对应的解决方案就是使用 **外部存储** 服务：
    * 数据库，如：MySQL、MongoDB
    
    * 缓存服务器，如：Redis、Memcache

    * 磁盘文件，多进程并发读写时需要加锁
    

* 普通的数据库和磁盘文件操作，存在较多 IO 等待时间。因此 *推荐使用*：
    * Redis 内存数据库，读写速度非常快
    
    * /dev/shm 内存文件系统，读写操作全部在内存中完成，无 IO 消耗，性能极高
    
* 除了使用存储之外，还可以使用 **共享内存** 来保存数据



### 共享内存
* PHP提供了多套共享内存的扩展，但实际上真正在实际项目中可用的并不多

* 比如 shm 扩展 / shmop 扩展 / apcu 扩展 


* swoole_table
    * Swoole 官方提供的共享内存读写工具，提供了 Key-Value 操作方式，使用非常简单。底层使用 **自旋锁** 实现，在大量并发读写操作时性能依然非常强劲。 **推荐使用** 。
   
   
* swoole_table 仍然存在一个两个缺点，使用时需要根据实际情况来选择。
    * 提前申请内存，swoole_table 在使用前就需要分配好内存，可能会占用较多内存
    
    * 无法动态扩容，swoole_table 内存管理是静态的，不支持动态申请新内存，因此一个 Table 在设置为N行之后，不能超过限制